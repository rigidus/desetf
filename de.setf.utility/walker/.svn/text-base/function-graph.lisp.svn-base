;;; -*- Mode: lisp; Syntax: ansi-common-lisp; Base: 10; Package: de.setf.utility.implementation; -*-
;;;

<DOCUMENTATION>
 <DESCRIPTION>
  <p>
  a simple function grapher </p>
  </DESCRIPTION>
 <COPYRIGHT YEAR='2003' AUTHOR='james adam anderson'>
  all rights reserved. no warranty.
  [<a href='http://www.setf.de/library/ncsl.html'>0</a>]
  [<a href='ncsl.html'>1</a>]</COPYRIGHT>
 <CHRONOLOGY>
  <DELTA DATE='20031101' />
  <DELTA DATE='20031210'>
   corrected qualifier slot name for walker class.
   changed function/function-name coercion and resolution to guard against macros, and to
   observe ccl callers constraints.</DELTA>
  <DELTA DATE='20060428' AUTHOR='janderson'>
   extended function calls to recognize apply</DELTA>
  </CHRONOLOGY>
 </DOCUMENTATION>

(in-package :de.setf.utility.implementation)

(modPackage :de.setf.utility.clos.graph
  (:use-only )
  (:use-by :de.setf.utility.implementation)
  (:export
   :function-walker
   :walk-function
   :graph-function
   :print-function
   :function-callers
   :function-calls
   ))



(defparameter *function-walk-depth* 0)
(defparameter *function-walk-depth-limit* nil)
(defparameter *function-walk-count* 0)
(defparameter *function-walk-count-limit* nil)

(defun coerce-to-function (datum)
  (typecase datum
    (null nil)
    (symbol (when (fboundp datum) (coerce-to-function (fdefinition datum))))
    (cons
     (cond ((eq (first datum) 'setf) (when (fboundp datum) (fdefinition datum)))
           ((eq (first datum) 'quote) (coerce-to-function (second datum)))))
    (function datum)))


<div>
 the graph is constructed by analysing function object to extract the respective callers and called.
 in the case of mcl, the calls set is provided in the runtime and the called set is generated by
 examining the disassembly. each implementation must provide the equivalent
 </div>

#-ccl
(warn "no definition for function-name")

#-ccl
(defGeneric function-callers (x)
  (:method ((x function)) (warn "no definition for function-callers")))
#+ccl
(defGeneric function-callers (x)
  (:documentation "mcl accepts a function name, but not a function")
  (:method ((x function)) (function-callers (function-name x)))
  (:method ((x function)) (warn "no definition for function-callers"))
  (:method ((x symbol)) (ccl::callers x))
  (:method ((x cons)) (when (and (eq (first x) 'setf) (fboundp x)) (ccl::callers x))))

(defGeneric function-calls (function)
  #+ccl
  (:method ((function function))
           (let ((disassembly (ccl::disassemble-list function))
                 (calls nil))
             (labels ((token-equal (x y)
                        (cond ((consp x)
                               (when (eq (first x) 'quote) (token-equal (second x) y)))
                              ((consp y)
                               (when (eq (first y) 'quote) (token-equal x (second y))))
                              ((and (or (stringp x) (symbolp x)) (or (stringp y) (symbolp y)))
                               (string-equal x y))))
                      (push-token (x)
                        (when (and (consp x) (eq (first x) 'quote)) (setf x (second x)))
                        (when (functionp x) (setf x (function-name x)))
                        (when (and (symbolp x) (fboundp x)) (pushnew x calls))))
               (loop (unless (rest disassembly) (return calls))
                     (destructuring-bind ((o1 set-nargs? &rest r1) (o2 &optional lwz? reg name fn? &rest r2) &rest r3)
                                         disassembly
                       (declare (ignore o1 o2 reg r2 r3))
                       ;; (print disassembly)
                       (when (and (or (token-equal "set-nargs" set-nargs?)
                                      (and (token-equal "bla" set-nargs?) (token-equal ".SPSPREADARGZ" (first r1))))
                                  (token-equal "lwz" lwz?)
                                  (token-equal "fn" fn?))
                         (push-token name)))
                     (pop disassembly)))))
  #+ccl
  (:method ((method method))
           (function-calls (method-function method)))
  #-ccl
  (:method ((function function))
           (warn "no definition for function-calls")
           nil)
  (:method ((function generic-function))
           (let ((calls (mapcar #'function-calls (generic-function-methods function))))
             (when calls
               (reduce #'union calls))))
  (:method ((function symbol))
           (when (fboundp function) (function-calls (fdefinition function)))))

;(function-calls 'print) (function-calls 'function-calls)

(defun function-package (datum)
  (typecase datum
    (symbol (symbol-package datum))
    (cons (function-package (second datum)))
    (function (function-package (function-name datum)))))



<div>
 
 </div>
(defClass function-walker (preorder-node-walker
                           preorder-link-walker
                           cyclic-walker
                           walk-qualifier)
  ((walk-qualifiers
    :allocation :class
    :initform '(callers calls relations other)
    :documentation
    "in general, a function walker combines methods for
     caller calls relations and other.")
   (effective-qualifiers
    :initform nil
    :accessor walker-effective-qualifiers
    :documentation
    "binds a list of the effective qualifiers for the particuler walker.
     these limit the relations followed.")))

(defmethod initialize-instance :after ((instance function-walker)
                                       &key (qualifiers nil qualifiers-p))
    (setf (walker-effective-qualifiers instance)
          (if qualifiers-p
            (remove-if-not #'(lambda (q) (find q qualifiers :test #'string-equal))
                           (walk-qualifiers instance))
            (walk-qualifiers instance))))

(defmethod walk-node-predecessors calls
           ((walker function-walker) (function function) (op t))
  (when (find 'calls (walker-effective-qualifiers walker))
    (dolist (calls (function-calls function))
      (when (setf calls (coerce-to-function calls))
        (unless (find function (getf (walker-node-properties walker calls) 'callers))
          (push calls (getf (walker-node-properties walker function) 'calls))
          (walk-link walker 'calls function calls op)))))
  function)

(defmethod walk-node-successors callers
           ((walker function-walker) (function function) (op t))
    (when (find 'callers (walker-effective-qualifiers walker)) (break)
      (dolist (caller (function-callers function))
        (when (setf caller (coerce-to-function caller))
          (unless (find function (getf (walker-node-properties walker caller) 'calls))
            (push caller (getf (walker-node-properties walker function) 'callers))
            (walk-link walker 'caller function caller op)))))
  function)

(defMethod walk-link :around
           ((walker function-walker) (relation t) (from function) (to function) (op t))
  (let* ((package (function-package to)))
    (when (and (find package *packages-to-walk*)
               (or (null *function-walk-depth-limit*) (<= *function-walk-depth* *function-walk-depth-limit*))
               (or (null *function-walk-count-limit*) (<= *function-walk-count* *function-walk-count-limit*)))
      (let ((*function-walk-depth* (1+ *function-walk-depth*)))
        (call-next-method) to))))

(defmethod walk-node :denominative ((navigator function-walker) (node t) (operator t)))
(defmethod walk-node-predecessors :denominative ((navigator function-walker) (node t) (operator t)))
(defmethod walk-node-successors :denominative ((navigator function-walker) (node t) (operator t)))
(defmethod walk-link :denominative ((walker function-walker) (relation t) (from t) (to t) (op t)))

;;;
;;; interface

(defGeneric walk-functions (root functions op &key &allow-other-keys)
  (:argument-precedence-order functions root op)
  (:method ((root function) (functions null) op &rest options)
           (apply #'walk-functions root (list (function-package root)) op options))
  (:method ((root t) (package-predicate function) op &rest options)
           (apply #'walk-packages root (remove-if-not package-predicate (list-all-packages)) op options))
  (:method ((root symbol) (packages t) (op t) &rest options)
           (apply #'walk-functions (fdefinition root) packages op options))
  (:method ((root function) (*packages-to-walk* cons) op &rest options)
           (setf *packages-to-walk* (mapcar #'coerce-to-package *packages-to-walk*))
           (walk-model root (apply #'make-instance 'function-walker options) op)))
            

(defun write-function-graph-statement (function &optional (other-function nil other-p) relation)
  (flet ((function-nickname (function)
           (let* ((name (function-name function))
                  (package (symbol-package name))
                  (p-nick (or (first (package-nicknames package))
                              (package-name package))))
             (if (eq package *package*)
               (symbol-name name)
               (concatenate 'string p-nick ":" (symbol-name name))))))
    (cond (other-p
           ;; a link
           (dot:dot-write-edge-statement dot:*dot-output*
                                         (function-nickname function) (function-nickname other-function)
                                         `(("label" . ,(string relation)))))
          (t
           (when (numberp *function-walk-count*) (incf *function-walk-count*))
           (dot:dot-write-node-statement dot:*dot-output* (function-nickname function) nil))))
  function)




(defun graph-functions (&key packages (stream *standard-output*) function
                             ((:depth-limit *function-walk-depth-limit*) *function-walk-depth-limit*)
                             ((:count-limit *function-walk-count-limit*) *function-walk-count-limit*)
                             (options nil)
                             &aux (*function-walk-count* 0))
  (dot:dot-write-graph stream
                       #'(lambda (grapher)
                           (declare (ignore grapher))
                           (dot-write-attribute *dot-output* "size" "8.5,11")
                           (write-string "; " *dot-output*)
                           (dot-write-attribute *dot-output* "ratio" "compress")
                           (write-string "; " *dot-output*)
                           (dot-write-attribute *dot-output* "rankdir" "LR")
                           (write-string "; " *dot-output*)
                           (dot-write-attribute *dot-output* "margin" ".5")
                           (write-string "; " *dot-output*)
                           (apply #'walk-functions function packages #'write-function-graph-statement
                                  options)))
  *function-walk-count*)

(defun print-functions (&key packages (stream *standard-output*) function
                             ((:depth-limit *function-walk-depth-limit*) *function-walk-depth-limit*)
                             ((:count-limit *function-walk-count-limit*) *function-walk-count-limit*)
                             &aux (*function-walk-count* 0))
  (flet ((print-function (function &optional (other nil other-p) relation)
           (cond (other-p
                  (terpri stream)
                  (dotimes (x (* 5 *function-walk-depth*)) (write-char #\space stream))
                  (format stream "~a: ~a" relation (function-name other)))
                 (t
                  (terpri stream)
                  (dotimes (x (* 5 *function-walk-depth*)) (write-char #\space stream))
                  (format stream "~a:" (function-name function))))
           function))
    (walk-functions function packages #'print-function)))



:EOF
